

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>scipy.special.basic &mdash; pulse2percept 0.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="pulse2percept 0.1.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> pulse2percept
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">pulse2percept</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>scipy.special.basic</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scipy.special.basic</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Author:  Travis Oliphant, 2002</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy._lib.six</span> <span class="k">import</span> <span class="n">xrange</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">isscalar</span><span class="p">,</span> <span class="n">iscomplex</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span>
                   <span class="n">where</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">place</span><span class="p">,</span> <span class="n">issubdtype</span><span class="p">,</span> <span class="n">extract</span><span class="p">,</span>
                   <span class="n">less</span><span class="p">,</span> <span class="n">inexact</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">atleast_1d</span><span class="p">,</span> <span class="n">sinc</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">._ufuncs</span> <span class="k">import</span> <span class="p">(</span><span class="n">ellipkm1</span><span class="p">,</span> <span class="n">mathieu_a</span><span class="p">,</span> <span class="n">mathieu_b</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">jv</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span>
                      <span class="n">psi</span><span class="p">,</span> <span class="n">_zeta</span><span class="p">,</span> <span class="n">hankel1</span><span class="p">,</span> <span class="n">hankel2</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">kv</span><span class="p">,</span> <span class="n">_gammaln</span><span class="p">,</span>
                      <span class="n">ndtri</span><span class="p">,</span> <span class="n">errprint</span><span class="p">,</span> <span class="n">poch</span><span class="p">,</span> <span class="n">binom</span><span class="p">,</span> <span class="n">hyp0f1</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">specfun</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">orthogonal</span>
<span class="kn">from</span> <span class="nn">._comb</span> <span class="k">import</span> <span class="n">_comb_int</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;agm&#39;</span><span class="p">,</span> <span class="s1">&#39;ai_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;assoc_laguerre&#39;</span><span class="p">,</span> <span class="s1">&#39;bei_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;beip_zeros&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ber_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;bernoulli&#39;</span><span class="p">,</span> <span class="s1">&#39;berp_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;bessel_diff_formula&#39;</span><span class="p">,</span>
           <span class="s1">&#39;bi_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;clpmn&#39;</span><span class="p">,</span> <span class="s1">&#39;comb&#39;</span><span class="p">,</span> <span class="s1">&#39;digamma&#39;</span><span class="p">,</span> <span class="s1">&#39;diric&#39;</span><span class="p">,</span> <span class="s1">&#39;ellipk&#39;</span><span class="p">,</span>
           <span class="s1">&#39;erf_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;erfcinv&#39;</span><span class="p">,</span> <span class="s1">&#39;erfinv&#39;</span><span class="p">,</span> <span class="s1">&#39;errprint&#39;</span><span class="p">,</span> <span class="s1">&#39;euler&#39;</span><span class="p">,</span> <span class="s1">&#39;factorial&#39;</span><span class="p">,</span>
           <span class="s1">&#39;factorialk&#39;</span><span class="p">,</span> <span class="s1">&#39;factorial2&#39;</span><span class="p">,</span> <span class="s1">&#39;fresnel_zeros&#39;</span><span class="p">,</span>
           <span class="s1">&#39;fresnelc_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;fresnels_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="s1">&#39;gammaln&#39;</span><span class="p">,</span> <span class="s1">&#39;h1vp&#39;</span><span class="p">,</span>
           <span class="s1">&#39;h2vp&#39;</span><span class="p">,</span> <span class="s1">&#39;hankel1&#39;</span><span class="p">,</span> <span class="s1">&#39;hankel2&#39;</span><span class="p">,</span> <span class="s1">&#39;hyp0f1&#39;</span><span class="p">,</span> <span class="s1">&#39;iv&#39;</span><span class="p">,</span> <span class="s1">&#39;ivp&#39;</span><span class="p">,</span> <span class="s1">&#39;jn_zeros&#39;</span><span class="p">,</span>
           <span class="s1">&#39;jnjnp_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;jnp_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;jnyn_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;jv&#39;</span><span class="p">,</span> <span class="s1">&#39;jvp&#39;</span><span class="p">,</span> <span class="s1">&#39;kei_zeros&#39;</span><span class="p">,</span>
           <span class="s1">&#39;keip_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;kelvin_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;ker_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;kerp_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;kv&#39;</span><span class="p">,</span>
           <span class="s1">&#39;kvp&#39;</span><span class="p">,</span> <span class="s1">&#39;lmbda&#39;</span><span class="p">,</span> <span class="s1">&#39;lpmn&#39;</span><span class="p">,</span> <span class="s1">&#39;lpn&#39;</span><span class="p">,</span> <span class="s1">&#39;lqmn&#39;</span><span class="p">,</span> <span class="s1">&#39;lqn&#39;</span><span class="p">,</span> <span class="s1">&#39;mathieu_a&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mathieu_b&#39;</span><span class="p">,</span> <span class="s1">&#39;mathieu_even_coef&#39;</span><span class="p">,</span> <span class="s1">&#39;mathieu_odd_coef&#39;</span><span class="p">,</span> <span class="s1">&#39;ndtri&#39;</span><span class="p">,</span>
           <span class="s1">&#39;obl_cv_seq&#39;</span><span class="p">,</span> <span class="s1">&#39;pbdn_seq&#39;</span><span class="p">,</span> <span class="s1">&#39;pbdv_seq&#39;</span><span class="p">,</span> <span class="s1">&#39;pbvv_seq&#39;</span><span class="p">,</span> <span class="s1">&#39;perm&#39;</span><span class="p">,</span>
           <span class="s1">&#39;polygamma&#39;</span><span class="p">,</span> <span class="s1">&#39;pro_cv_seq&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">,</span> <span class="s1">&#39;riccati_jn&#39;</span><span class="p">,</span> <span class="s1">&#39;riccati_yn&#39;</span><span class="p">,</span>
           <span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="s1">&#39;sph_in&#39;</span><span class="p">,</span> <span class="s1">&#39;sph_inkn&#39;</span><span class="p">,</span>
           <span class="s1">&#39;sph_jn&#39;</span><span class="p">,</span> <span class="s1">&#39;sph_jnyn&#39;</span><span class="p">,</span> <span class="s1">&#39;sph_kn&#39;</span><span class="p">,</span> <span class="s1">&#39;sph_yn&#39;</span><span class="p">,</span> <span class="s1">&#39;y0_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;y1_zeros&#39;</span><span class="p">,</span>
           <span class="s1">&#39;y1p_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;yn_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;ynp_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;yv&#39;</span><span class="p">,</span> <span class="s1">&#39;yvp&#39;</span><span class="p">,</span> <span class="s1">&#39;zeta&#39;</span><span class="p">,</span>
           <span class="s1">&#39;SpecialFunctionWarning&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">SpecialFunctionWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warning that can be issued with ``errprint(True)``&quot;&quot;&quot;</span>
    <span class="k">pass</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">SpecialFunctionWarning</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">diric</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Periodic sinc function, also called the Dirichlet function.</span>

<span class="sd">    The Dirichlet function is defined as::</span>

<span class="sd">        diric(x) = sin(x * n/2) / (n * sin(x / 2)),</span>

<span class="sd">    where `n` is a positive integer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Input data</span>
<span class="sd">    n : int</span>
<span class="sd">        Integer defining the periodicity.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diric : ndarray</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-8*np.pi, 8*np.pi, num=201)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 8));</span>
<span class="sd">    &gt;&gt;&gt; for idx, n in enumerate([2, 3, 4, 9]):</span>
<span class="sd">    ...     plt.subplot(2, 2, idx+1)</span>
<span class="sd">    ...     plt.plot(x, special.diric(x, n))</span>
<span class="sd">    ...     plt.title(&#39;diric, n={}&#39;.format(n))</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    The following example demonstrates that `diric` gives the magnitudes</span>
<span class="sd">    (modulo the sign and scaling) of the Fourier coefficients of a</span>
<span class="sd">    rectangular pulse.</span>

<span class="sd">    Suppress output of values that are effectively 0:</span>

<span class="sd">    &gt;&gt;&gt; np.set_printoptions(suppress=True)</span>

<span class="sd">    Create a signal `x` of length `m` with `k` ones:</span>

<span class="sd">    &gt;&gt;&gt; m = 8</span>
<span class="sd">    &gt;&gt;&gt; k = 3</span>
<span class="sd">    &gt;&gt;&gt; x = np.zeros(m)</span>
<span class="sd">    &gt;&gt;&gt; x[:k] = 1</span>

<span class="sd">    Use the FFT to compute the Fourier transform of `x`, and</span>
<span class="sd">    inspect the magnitudes of the coefficients:</span>

<span class="sd">    &gt;&gt;&gt; np.abs(np.fft.fft(x))</span>
<span class="sd">    array([ 3.        ,  2.41421356,  1.        ,  0.41421356,  1.        ,</span>
<span class="sd">            0.41421356,  1.        ,  2.41421356])</span>

<span class="sd">    Now find the same values (up to sign) using `diric`.  We multiply</span>
<span class="sd">    by `k` to account for the different scaling conventions of</span>
<span class="sd">    `numpy.fft.fft` and `diric`:</span>

<span class="sd">    &gt;&gt;&gt; theta = np.linspace(0, 2*np.pi, m, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; k * special.diric(theta, k)</span>
<span class="sd">    array([ 3.        ,  2.41421356,  1.        , -0.41421356, -1.        ,</span>
<span class="sd">           -0.41421356,  1.        ,  2.41421356])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
        <span class="n">ytype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ytype</span> <span class="o">=</span> <span class="nb">float</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ytype</span><span class="p">)</span>

    <span class="c1"># empirical minval for 32, 64 or 128 bit float computations</span>
    <span class="c1"># where sin(x/2) &lt; minval, result is fixed at +1 or -1</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">ytype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">18</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">11</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">ytype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">15</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">7</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span>

    <span class="n">mask1</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask1</span><span class="p">,</span> <span class="n">nan</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mask1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minval</span><span class="p">)</span>
    <span class="n">xsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">nsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">zsub</span> <span class="o">=</span> <span class="n">xsub</span> <span class="o">/</span> <span class="n">pi</span>
    <span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask2</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">zsub</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">nsub</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mask1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mask2</span><span class="p">)</span>
    <span class="n">xsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">nsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">dsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
    <span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">nsub</span><span class="o">*</span><span class="n">xsub</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nsub</span><span class="o">*</span><span class="n">dsub</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">gammaln</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logarithm of the absolute value of the Gamma function for real inputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">        Values on the real line at which to compute ``gammaln``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gammaln : ndarray</span>
<span class="sd">        Values of ``gammaln`` at x.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    gammasgn : sign of the gamma function</span>
<span class="sd">    loggamma : principal branch of the logarithm of the gamma function</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When used in conjunction with `gammasgn`, this function is useful</span>
<span class="sd">    for working in logspace on the real axis without having to deal with</span>
<span class="sd">    complex numbers, via the relation ``exp(gammaln(x)) = gammasgn(x)*gamma(x)``.</span>

<span class="sd">    Note that `gammaln` currently accepts complex-valued inputs, but it is not</span>
<span class="sd">    the same function as for real-valued inputs, and the branch is not</span>
<span class="sd">    well-defined --- using `gammaln` with complex is deprecated and will be</span>
<span class="sd">    disallowed in future Scipy versions.</span>

<span class="sd">    For complex-valued log-gamma, use `loggamma` instead of `gammaln`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">((</span><span class="s2">&quot;Use of gammaln for complex arguments is &quot;</span>
                       <span class="s2">&quot;deprecated as of scipy 0.18.0. Use &quot;</span>
                       <span class="s2">&quot;scipy.special.loggamma instead.&quot;</span><span class="p">),</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_gammaln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">jnjnp_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel functions Jn and Jn&#39;.</span>

<span class="sd">    Results are arranged in order of the magnitudes of the zeros.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number (&lt;=1200) of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zo[l-1] : ndarray</span>
<span class="sd">        Value of the lth zero of Jn(x) and Jn&#39;(x). Of length `nt`.</span>
<span class="sd">    n[l-1] : ndarray</span>
<span class="sd">        Order of the Jn(x) or Jn&#39;(x) associated with lth zero. Of length `nt`.</span>
<span class="sd">    m[l-1] : ndarray</span>
<span class="sd">        Serial number of the zeros of Jn(x) or Jn&#39;(x) associated</span>
<span class="sd">        with lth zero. Of length `nt`.</span>
<span class="sd">    t[l-1] : ndarray</span>
<span class="sd">        0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn&#39;(x). Of</span>
<span class="sd">        length `nt`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    jn_zeros, jnp_zeros : to get separated arrays of zeros.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1200</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number must be integer &lt;= 1200.&quot;</span><span class="p">)</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">zo</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">jdzo</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zo</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">[:</span><span class="n">nt</span><span class="p">],</span> <span class="n">m</span><span class="p">[:</span><span class="n">nt</span><span class="p">],</span> <span class="n">t</span><span class="p">[:</span><span class="n">nt</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel functions Jn(x), Jn&#39;(x), Yn(x), and Yn&#39;(x).</span>

<span class="sd">    Returns 4 arrays of length `nt`, corresponding to the first `nt` zeros of</span>
<span class="sd">    Jn(x), Jn&#39;(x), Yn(x), and Yn&#39;(x), respectively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of the Bessel functions</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number (&lt;=1200) of zeros to compute</span>

<span class="sd">    See jn_zeros, jnp_zeros, yn_zeros, ynp_zeros to get separate arrays.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt &gt; 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">jyzo</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">jn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function Jn(x).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">jnp_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function derivative Jn&#39;(x).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">yn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function Yn(x).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">ynp_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function derivative Yn&#39;(x).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">y0_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel function Y0(z), and derivative at each zero.</span>

<span class="sd">    The derivatives are given by Y0&#39;(z0) = -Y1(z0) at each zero z0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>
<span class="sd">    complex : bool, default False</span>
<span class="sd">        Set to False to return only the real zeros; set to True to return only</span>
<span class="sd">        the complex zeros with negative real part and positive imaginary part.</span>
<span class="sd">        Note that the complex conjugates of the latter are also zeros of the</span>
<span class="sd">        function, but are not returned by this routine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z0n : ndarray</span>
<span class="sd">        Location of nth zero of Y0(z)</span>
<span class="sd">    y0pz0n : ndarray</span>
<span class="sd">        Value of derivative Y0&#39;(z0) for nth zero</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalar positive integer.&quot;</span><span class="p">)</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kc</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">complex</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">y1_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel function Y1(z), and derivative at each zero.</span>

<span class="sd">    The derivatives are given by Y1&#39;(z1) = Y0(z1) at each zero z1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>
<span class="sd">    complex : bool, default False</span>
<span class="sd">        Set to False to return only the real zeros; set to True to return only</span>
<span class="sd">        the complex zeros with negative real part and positive imaginary part.</span>
<span class="sd">        Note that the complex conjugates of the latter are also zeros of the</span>
<span class="sd">        function, but are not returned by this routine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z1n : ndarray</span>
<span class="sd">        Location of nth zero of Y1(z)</span>
<span class="sd">    y1pz1n : ndarray</span>
<span class="sd">        Value of derivative Y1&#39;(z1) for nth zero</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalar positive integer.&quot;</span><span class="p">)</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">kc</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">complex</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">y1p_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel derivative Y1&#39;(z), and value at each zero.</span>

<span class="sd">    The values are given by Y1(z1) at each z1 where Y1&#39;(z1)=0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>
<span class="sd">    complex : bool, default False</span>
<span class="sd">        Set to False to return only the real zeros; set to True to return only</span>
<span class="sd">        the complex zeros with negative real part and positive imaginary part.</span>
<span class="sd">        Note that the complex conjugates of the latter are also zeros of the</span>
<span class="sd">        function, but are not returned by this routine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z1pn : ndarray</span>
<span class="sd">        Location of nth zero of Y1&#39;(z)</span>
<span class="sd">    y1z1pn : ndarray</span>
<span class="sd">        Value of derivative Y1(z1) for nth zero</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalar positive integer.&quot;</span><span class="p">)</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">kc</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">complex</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
    <span class="c1"># from AMS55.</span>
    <span class="c1"># L(v, z) = J(v, z), Y(v, z), H1(v, z), H2(v, z), phase = -1</span>
    <span class="c1"># L(v, z) = I(v, z) or exp(v*pi*i)K(v, z), phase = 1</span>
    <span class="c1"># For K, you can pull out the exp((v-k)*pi*i) into the caller</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">phase</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">i</span>   <span class="c1"># = choose(k, i)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">p</span><span class="o">*</span><span class="n">L</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>


<span class="n">bessel_diff_formula</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">_bessel_diff_formula</span><span class="p">,</span>
    <span class="n">message</span><span class="o">=</span><span class="s2">&quot;bessel_diff_formula is a private function, do not use it!&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">jvp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nth derivative of Bessel function Jv(z) with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           http://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">jv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">yvp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nth derivative of Bessel function Yv(z) with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           http://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">yv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kvp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nth derivative of real-order modified Bessel function Kv(z)</span>

<span class="sd">    Kv(z) is the modified Bessel function of the second kind.</span>
<span class="sd">    Derivative is calculated with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like of float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : array_like of complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of derivative.  Default is first derivative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The results</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate multiple values at order 5:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import kvp</span>
<span class="sd">    &gt;&gt;&gt; kvp(5, (1, 2, 3+5j))</span>
<span class="sd">    array([-1849.0354+0.j    ,   -25.7735+0.j    ,    -0.0307+0.0875j])</span>

<span class="sd">    Calculate for a single value at multiple orders:</span>

<span class="sd">    &gt;&gt;&gt; kvp((4, 4.5, 5), 1)</span>
<span class="sd">    array([ -184.0309,  -568.9585, -1849.0354])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.29.5 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 6.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           http://dlmf.nist.gov/10.29.E5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">kv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ivp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nth derivative of modified Bessel function Iv(z) with respect</span>
<span class="sd">    to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like of float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : array_like of complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.29.5 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 6.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           http://dlmf.nist.gov/10.29.E5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">iv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">h1vp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nth derivative of Hankel function H1v(z) with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of Hankel function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           http://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hankel1</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hankel1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">h2vp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nth derivative of Hankel function H2v(z) with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of Hankel function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           http://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hankel2</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hankel2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;scipy.special.sph_jn is deprecated in scipy 0.18.0. &quot;</span>
                      <span class="s2">&quot;Use scipy.special.spherical_jn instead. &quot;</span>
                      <span class="s2">&quot;Note that the new function has a different signature.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sph_jn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute spherical Bessel function jn(z) and derivative.</span>

<span class="sd">    This function computes the value and first derivative of jn(z) for all</span>
<span class="sd">    orders up to and including n.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of jn to compute</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jn : ndarray</span>
<span class="sd">        Value of j0(z), ..., jn(z)</span>
<span class="sd">    jnp : ndarray</span>
<span class="sd">        First derivative j0&#39;(z), ..., jn&#39;(z)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    spherical_jn</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 8.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">ynp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">csphjy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">sphj</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">jnp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;scipy.special.sph_yn is deprecated in scipy 0.18.0. &quot;</span>
                      <span class="s2">&quot;Use scipy.special.spherical_yn instead. &quot;</span>
                      <span class="s2">&quot;Note that the new function has a different signature.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sph_yn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute spherical Bessel function yn(z) and derivative.</span>

<span class="sd">    This function computes the value and first derivative of yn(z) for all</span>
<span class="sd">    orders up to and including n.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of yn to compute</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    yn : ndarray</span>
<span class="sd">        Value of y0(z), ..., yn(z)</span>
<span class="sd">    ynp : ndarray</span>
<span class="sd">        First derivative y0&#39;(z), ..., yn&#39;(z)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    spherical_yn</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 8.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="ow">or</span> <span class="n">less</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">ynp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">csphjy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">ynp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">sphy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">yn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">ynp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;scipy.special.sph_jnyn is deprecated in scipy 0.18.0. &quot;</span>
                      <span class="s2">&quot;Use scipy.special.spherical_jn and &quot;</span>
                      <span class="s2">&quot;scipy.special.spherical_yn instead. &quot;</span>
                      <span class="s2">&quot;Note that the new function has a different signature.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sph_jnyn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute spherical Bessel functions jn(z) and yn(z) and derivatives.</span>

<span class="sd">    This function computes the value and first derivative of jn(z) and yn(z)</span>
<span class="sd">    for all orders up to and including n.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of jn and yn to compute</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jn : ndarray</span>
<span class="sd">        Value of j0(z), ..., jn(z)</span>
<span class="sd">    jnp : ndarray</span>
<span class="sd">        First derivative j0&#39;(z), ..., jn&#39;(z)</span>
<span class="sd">    yn : ndarray</span>
<span class="sd">        Value of y0(z), ..., yn(z)</span>
<span class="sd">    ynp : ndarray</span>
<span class="sd">        First derivative y0&#39;(z), ..., yn&#39;(z)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    spherical_jn</span>
<span class="sd">    spherical_yn</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 8.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="ow">or</span> <span class="n">less</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">ynp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">csphjy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">ynp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">sphy</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">sphj</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">jnp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">yn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">ynp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;scipy.special.sph_in is deprecated in scipy 0.18.0. &quot;</span>
                      <span class="s2">&quot;Use scipy.special.spherical_in instead. &quot;</span>
                      <span class="s2">&quot;Note that the new function has a different signature.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sph_in</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute spherical Bessel function in(z) and derivative.</span>

<span class="sd">    This function computes the value and first derivative of in(z) for all</span>
<span class="sd">    orders up to and including n.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of in to compute</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    in : ndarray</span>
<span class="sd">        Value of i0(z), ..., in(z)</span>
<span class="sd">    inp : ndarray</span>
<span class="sd">        First derivative i0&#39;(z), ..., in&#39;(z)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    spherical_in</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 8.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">In</span><span class="p">,</span> <span class="n">Inp</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">knp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">csphik</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">In</span><span class="p">,</span> <span class="n">Inp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">sphi</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">In</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">Inp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;scipy.special.sph_kn is deprecated in scipy 0.18.0. &quot;</span>
                      <span class="s2">&quot;Use scipy.special.spherical_kn instead. &quot;</span>
                      <span class="s2">&quot;Note that the new function has a different signature.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sph_kn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute spherical Bessel function kn(z) and derivative.</span>

<span class="sd">    This function computes the value and first derivative of kn(z) for all</span>
<span class="sd">    orders up to and including n.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of kn to compute</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kn : ndarray</span>
<span class="sd">        Value of k0(z), ..., kn(z)</span>
<span class="sd">    knp : ndarray</span>
<span class="sd">        First derivative k0&#39;(z), ..., kn&#39;(z)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    spherical_kn</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 8.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="ow">or</span> <span class="n">less</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">In</span><span class="p">,</span> <span class="n">Inp</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">knp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">csphik</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">knp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">sphk</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">knp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;scipy.special.sph_inkn is deprecated in scipy 0.18.0. &quot;</span>
                      <span class="s2">&quot;Use scipy.special.spherical_in and &quot;</span>
                      <span class="s2">&quot;scipy.special.spherical_kn instead. &quot;</span>
                      <span class="s2">&quot;Note that the new function has a different signature.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sph_inkn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute spherical Bessel functions in(z), kn(z), and derivatives.</span>

<span class="sd">    This function computes the value and first derivative of in(z) and kn(z)</span>
<span class="sd">    for all orders up to and including n.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of in and kn to compute</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    in : ndarray</span>
<span class="sd">        Value of i0(z), ..., in(z)</span>
<span class="sd">    inp : ndarray</span>
<span class="sd">        First derivative i0&#39;(z), ..., in&#39;(z)</span>
<span class="sd">    kn : ndarray</span>
<span class="sd">        Value of k0(z), ..., kn(z)</span>
<span class="sd">    knp : ndarray</span>
<span class="sd">        First derivative k0&#39;(z), ..., kn&#39;(z)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    spherical_in</span>
<span class="sd">    spherical_kn</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 8.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="ow">or</span> <span class="n">less</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">In</span><span class="p">,</span> <span class="n">Inp</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">knp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">csphik</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">In</span><span class="p">,</span> <span class="n">Inp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">sphi</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">nm</span><span class="p">,</span> <span class="n">kn</span><span class="p">,</span> <span class="n">knp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">sphk</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">In</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">Inp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">kn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">knp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">riccati_jn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Compute Ricatti-Bessel function of the first kind and its derivative.</span>

<span class="sd">    The Ricatti-Bessel function of the first kind is defined as :math:`x</span>
<span class="sd">    j_n(x)`, where :math:`j_n` is the spherical Bessel function of the first</span>
<span class="sd">    kind of order :math:`n`.</span>

<span class="sd">    This function computes the value and first derivative of the</span>
<span class="sd">    Ricatti-Bessel function for all orders up to and including `n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of function to compute</span>
<span class="sd">    x : float</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jn : ndarray</span>
<span class="sd">        Value of j0(x), ..., jn(x)</span>
<span class="sd">    jnp : ndarray</span>
<span class="sd">        First derivative j0&#39;(x), ..., jn&#39;(x)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The computation is carried out via backward recurrence, using the</span>
<span class="sd">    relation DLMF 10.51.1 [2]_.</span>

<span class="sd">    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming</span>
<span class="sd">    Jin [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           http://dlmf.nist.gov/10.51.E1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">rctj</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">jnp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">riccati_yn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute Ricatti-Bessel function of the second kind and its derivative.</span>

<span class="sd">    The Ricatti-Bessel function of the second kind is defined as :math:`x</span>
<span class="sd">    y_n(x)`, where :math:`y_n` is the spherical Bessel function of the second</span>
<span class="sd">    kind of order :math:`n`.</span>

<span class="sd">    This function computes the value and first derivative of the function for</span>
<span class="sd">    all orders up to and including `n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of function to compute</span>
<span class="sd">    x : float</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    yn : ndarray</span>
<span class="sd">        Value of y0(x), ..., yn(x)</span>
<span class="sd">    ynp : ndarray</span>
<span class="sd">        First derivative y0&#39;(x), ..., yn&#39;(x)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The computation is carried out via ascending recurrence, using the</span>
<span class="sd">    relation DLMF 10.51.1 [2]_.</span>

<span class="sd">    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming</span>
<span class="sd">    Jin [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           http://dlmf.nist.gov/10.51.E1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">rcty</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">jnp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">erfinv</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Inverse function for erf.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ndtri</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">erfcinv</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Inverse function for erfc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ndtri</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">erf_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt complex zeros of error function erf(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cerzo</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fresnelc_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt complex zeros of cosine Fresnel integral C(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fresnels_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt complex zeros of sine Fresnel integral S(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fresnel_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nt</span><span class="p">),</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">assoc_laguerre</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the generalized (associated) Laguerre polynomial of degree n and order k.</span>

<span class="sd">    The polynomial :math:`L^{(k)}_n(x)` is orthogonal over ``[0, inf)``,</span>
<span class="sd">    with weighting function ``exp(-x) * x**k`` with ``k &gt; -1``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `assoc_laguerre` is a simple wrapper around `eval_genlaguerre`, with</span>
<span class="sd">    reversed argument order ``(x, n, k=0.0) --&gt; (n, k, x)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">orthogonal</span><span class="o">.</span><span class="n">eval_genlaguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="n">digamma</span> <span class="o">=</span> <span class="n">psi</span>


<span class="k">def</span> <span class="nf">polygamma</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Polygamma function n.</span>

<span class="sd">    This is the nth derivative of the digamma (psi) function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : array_like of int</span>
<span class="sd">        The order of the derivative of `psi`.</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Where to evaluate the polygamma function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    polygamma : ndarray</span>
<span class="sd">        The result.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; x = [2, 3, 25.5]</span>
<span class="sd">    &gt;&gt;&gt; special.polygamma(1, x)</span>
<span class="sd">    array([ 0.64493407,  0.39493407,  0.03999467])</span>
<span class="sd">    &gt;&gt;&gt; special.polygamma(0, x) == special.psi(x)</span>
<span class="sd">    array([ True,  True,  True], dtype=bool)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">fac2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">zeta</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fac2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mathieu_even_coef</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Fourier coefficients for even Mathieu and modified Mathieu functions.</span>

<span class="sd">    The Fourier series of the even solutions of the Mathieu differential</span>
<span class="sd">    equation are of the form</span>

<span class="sd">    .. math:: \mathrm{ce}_{2n}(z, q) = \sum_{k=0}^{\infty} A_{(2n)}^{(2k)} \cos 2kz</span>

<span class="sd">    .. math:: \mathrm{ce}_{2n+1}(z, q) = \sum_{k=0}^{\infty} A_{(2n+1)}^{(2k+1)} \cos (2k+1)z</span>

<span class="sd">    This function returns the coefficients :math:`A_{(2n)}^{(2k)}` for even</span>
<span class="sd">    input m=2n, and the coefficients :math:`A_{(2n+1)}^{(2k+1)}` for odd input</span>
<span class="sd">    m=2n+1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">        Order of Mathieu functions.  Must be non-negative.</span>
<span class="sd">    q : float (&gt;=0)</span>
<span class="sd">        Parameter of Mathieu functions.  Must be non-negative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ak : ndarray</span>
<span class="sd">        Even or odd Fourier coefficients, corresponding to even or odd m.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions</span>
<span class="sd">           http://dlmf.nist.gov/28.4#i</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m and q must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q &gt;=0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be an integer &gt;=0.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">7.5</span> <span class="o">+</span> <span class="mf">56.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mf">134.7</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="mf">90.7</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">17.0</span> <span class="o">+</span> <span class="mf">3.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="o">.</span><span class="mi">126</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="o">.</span><span class="mi">0037</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="n">km</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qm</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">km</span> <span class="o">&gt;</span> <span class="mi">251</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning, too many predicted coefficients.&quot;</span><span class="p">)</span>
    <span class="n">kd</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">kd</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">mathieu_a</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcoef</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fc</span><span class="p">[:</span><span class="n">km</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">mathieu_odd_coef</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Fourier coefficients for even Mathieu and modified Mathieu functions.</span>

<span class="sd">    The Fourier series of the odd solutions of the Mathieu differential</span>
<span class="sd">    equation are of the form</span>

<span class="sd">    .. math:: \mathrm{se}_{2n+1}(z, q) = \sum_{k=0}^{\infty} B_{(2n+1)}^{(2k+1)} \sin (2k+1)z</span>

<span class="sd">    .. math:: \mathrm{se}_{2n+2}(z, q) = \sum_{k=0}^{\infty} B_{(2n+2)}^{(2k+2)} \sin (2k+2)z</span>

<span class="sd">    This function returns the coefficients :math:`B_{(2n+2)}^{(2k+2)}` for even</span>
<span class="sd">    input m=2n+2, and the coefficients :math:`B_{(2n+1)}^{(2k+1)}` for odd</span>
<span class="sd">    input m=2n+1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">        Order of Mathieu functions.  Must be non-negative.</span>
<span class="sd">    q : float (&gt;=0)</span>
<span class="sd">        Parameter of Mathieu functions.  Must be non-negative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Bk : ndarray</span>
<span class="sd">        Even or odd Fourier coefficients, corresponding to even or odd m.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m and q must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q &gt;=0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be an integer &gt; 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">7.5</span> <span class="o">+</span> <span class="mf">56.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mf">134.7</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="mf">90.7</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">17.0</span> <span class="o">+</span> <span class="mf">3.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="o">.</span><span class="mi">126</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="o">.</span><span class="mi">0037</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="n">km</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qm</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">km</span> <span class="o">&gt;</span> <span class="mi">251</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning, too many predicted coefficients.&quot;</span><span class="p">)</span>
    <span class="n">kd</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">kd</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">mathieu_b</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcoef</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fc</span><span class="p">[:</span><span class="n">km</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">lpmn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Associated Legendre function of the first kind, Pmn(z).</span>

<span class="sd">    Computes the associated Legendre function of the first kind of order m and</span>
<span class="sd">    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn&#39;(z)``.</span>
<span class="sd">    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and</span>
<span class="sd">    ``Pmn&#39;(z)`` for all orders from ``0..m`` and degrees from ``0..n``.</span>

<span class="sd">    This function takes a real argument ``z``. For complex arguments ``z``</span>
<span class="sd">    use clpmn instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       ``|m| &lt;= n``; the order of the Legendre function.</span>
<span class="sd">    n : int</span>
<span class="sd">       where ``n &gt;= 0``; the degree of the Legendre function.  Often</span>
<span class="sd">       called ``l`` (lower case L) in descriptions of the associated</span>
<span class="sd">       Legendre function</span>
<span class="sd">    z : float</span>
<span class="sd">        Input value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pmn_z : (m+1, n+1) array</span>
<span class="sd">       Values for all orders 0..m and degrees 0..n</span>
<span class="sd">    Pmn_d_z : (m+1, n+1) array</span>
<span class="sd">       Derivatives for all orders 0..m and degrees 0..n</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    clpmn: associated Legendre functions of the first kind for complex z</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the interval (-1, 1), Ferrer&#39;s function of the first kind is</span>
<span class="sd">    returned. The phase convention used for the intervals (1, inf)</span>
<span class="sd">    and (-inf, -1) is such that the result is always real.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions</span>
<span class="sd">           http://dlmf.nist.gov/14.3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be &lt;= n.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z must be scalar.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be real. Use clpmn instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="o">-</span><span class="n">m</span>
        <span class="n">mf</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">errprint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Ferrer function; DLMF 14.9.3</span>
            <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                           <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">mf</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Match to clpmn; DLMF 14.9.13</span>
            <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">errprint</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">m</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lpmn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">fixarr</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span> <span class="o">*</span> <span class="n">fixarr</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">pd</span>


<span class="k">def</span> <span class="nf">clpmn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Associated Legendre function of the first kind, Pmn(z).</span>

<span class="sd">    Computes the associated Legendre function of the first kind of order m and</span>
<span class="sd">    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn&#39;(z)``.</span>
<span class="sd">    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and</span>
<span class="sd">    ``Pmn&#39;(z)`` for all orders from ``0..m`` and degrees from ``0..n``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       ``|m| &lt;= n``; the order of the Legendre function.</span>
<span class="sd">    n : int</span>
<span class="sd">       where ``n &gt;= 0``; the degree of the Legendre function.  Often</span>
<span class="sd">       called ``l`` (lower case L) in descriptions of the associated</span>
<span class="sd">       Legendre function</span>
<span class="sd">    z : float or complex</span>
<span class="sd">        Input value.</span>
<span class="sd">    type : int, optional</span>
<span class="sd">       takes values 2 or 3</span>
<span class="sd">       2: cut on the real axis ``|x| &gt; 1``</span>
<span class="sd">       3: cut on the real axis ``-1 &lt; x &lt; 1`` (default)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pmn_z : (m+1, n+1) array</span>
<span class="sd">       Values for all orders ``0..m`` and degrees ``0..n``</span>
<span class="sd">    Pmn_d_z : (m+1, n+1) array</span>
<span class="sd">       Derivatives for all orders ``0..m`` and degrees ``0..n``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lpmn: associated Legendre functions of the first kind for real z</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    By default, i.e. for ``type=3``, phase conventions are chosen according</span>
<span class="sd">    to [1]_ such that the function is analytic. The cut lies on the interval</span>
<span class="sd">    (-1, 1). Approaching the cut from above or below in general yields a phase</span>
<span class="sd">    factor with respect to Ferrer&#39;s function of the first kind</span>
<span class="sd">    (cf. `lpmn`).</span>

<span class="sd">    For ``type=2`` a cut at ``|x| &gt; 1`` is chosen. Approaching the real values</span>
<span class="sd">    on the interval (-1, 1) in the complex plane yields Ferrer&#39;s function</span>
<span class="sd">    of the first kind.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions</span>
<span class="sd">           http://dlmf.nist.gov/14.21</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be &lt;= n.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z must be scalar.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">type</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;type must be either 2 or 3.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="o">-</span><span class="n">m</span>
        <span class="n">mf</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">errprint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                           <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">mf</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">errprint</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">m</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">clpmn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">type</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">fixarr</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span> <span class="o">*</span> <span class="n">fixarr</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">pd</span>


<span class="k">def</span> <span class="nf">lqmn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Associated Legendre function of the second kind, Qmn(z).</span>

<span class="sd">    Computes the associated Legendre function of the second kind of order m and</span>
<span class="sd">    degree n, ``Qmn(z)`` = :math:`Q_n^m(z)`, and its derivative, ``Qmn&#39;(z)``.</span>
<span class="sd">    Returns two arrays of size ``(m+1, n+1)`` containing ``Qmn(z)`` and</span>
<span class="sd">    ``Qmn&#39;(z)`` for all orders from ``0..m`` and degrees from ``0..n``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       ``|m| &lt;= n``; the order of the Legendre function.</span>
<span class="sd">    n : int</span>
<span class="sd">       where ``n &gt;= 0``; the degree of the Legendre function.  Often</span>
<span class="sd">       called ``l`` (lower case L) in descriptions of the associated</span>
<span class="sd">       Legendre function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Input value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Qmn_z : (m+1, n+1) array</span>
<span class="sd">       Values for all orders 0..m and degrees 0..n</span>
<span class="sd">    Qmn_d_z : (m+1, n+1) array</span>
<span class="sd">       Derivatives for all orders 0..m and degrees 0..n</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z must be scalar.&quot;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Ensure neither m nor n == 0</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">clqmn</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lqmn</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q</span><span class="p">[:(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">qd</span><span class="p">[:(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">bernoulli</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bernoulli numbers B0..Bn (inclusive).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">bernob</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n1</span><span class="p">))[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">euler</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Euler numbers E0..En (inclusive).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">eulerb</span><span class="p">(</span><span class="n">n1</span><span class="p">)[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">lpn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Legendre functions of the first kind, Pn(z).</span>

<span class="sd">    Compute sequence of Legendre functions of the first kind (polynomials),</span>
<span class="sd">    Pn(z) and derivatives for all degrees from 0 to n (inclusive).</span>

<span class="sd">    See also special.legendre for polynomial class.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">pn</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">clpn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pn</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lpn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">pd</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">lqn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Legendre functions of the second kind, Qn(z).</span>

<span class="sd">    Compute sequence of Legendre functions of the second kind, Qn(z) and</span>
<span class="sd">    derivatives for all degrees from 0 to n (inclusive).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">qn</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">clqn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qn</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lqnb</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">qd</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">ai_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `nt` zeros and values of the Airy function Ai and its derivative.</span>

<span class="sd">    Computes the first `nt` zeros, `a`, of the Airy function Ai(x);</span>
<span class="sd">    first `nt` zeros, `ap`, of the derivative of the Airy function Ai&#39;(x);</span>
<span class="sd">    the corresponding values Ai(a&#39;);</span>
<span class="sd">    and the corresponding values Ai&#39;(a).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        First `nt` zeros of Ai(x)</span>
<span class="sd">    ap : ndarray</span>
<span class="sd">        First `nt` zeros of Ai&#39;(x)</span>
<span class="sd">    ai : ndarray</span>
<span class="sd">        Values of Ai(x) evaluated at first `nt` zeros of Ai&#39;(x)</span>
<span class="sd">    aip : ndarray</span>
<span class="sd">        Values of Ai&#39;(x) evaluated at first `nt` zeros of Ai(x)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be a positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">airyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bi_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `nt` zeros and values of the Airy function Bi and its derivative.</span>

<span class="sd">    Computes the first `nt` zeros, b, of the Airy function Bi(x);</span>
<span class="sd">    first `nt` zeros, b&#39;, of the derivative of the Airy function Bi&#39;(x);</span>
<span class="sd">    the corresponding values Bi(b&#39;);</span>
<span class="sd">    and the corresponding values Bi&#39;(b).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        First `nt` zeros of Bi(x)</span>
<span class="sd">    bp : ndarray</span>
<span class="sd">        First `nt` zeros of Bi&#39;(x)</span>
<span class="sd">    bi : ndarray</span>
<span class="sd">        Values of Bi(x) evaluated at first `nt` zeros of Bi&#39;(x)</span>
<span class="sd">    bip : ndarray</span>
<span class="sd">        Values of Bi&#39;(x) evaluated at first `nt` zeros of Bi(x)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be a positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">airyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lmbda</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Jahnke-Emden Lambda function, Lambdav(x).</span>

<span class="sd">    This function is defined as [2]_,</span>

<span class="sd">    .. math:: \Lambda_v(x) = \Gamma(v+1) \frac{J_v(x)}{(x/2)^v},</span>

<span class="sd">    where :math:`\Gamma` is the gamma function and :math:`J_v` is the</span>
<span class="sd">    Bessel function of the first kind.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of the Lambda function</span>
<span class="sd">    x : float</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vl : ndarray</span>
<span class="sd">        Values of Lambda_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>
<span class="sd">    dl : ndarray</span>
<span class="sd">        Derivatives Lambda_vi&#39;(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>
<span class="sd">    .. [2] Jahnke, E. and Emde, F. &quot;Tables of Functions with Formulae and</span>
<span class="sd">           Curves&quot; (4th ed.), Dover, 1945</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;argument must be &gt; 0.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">n</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">v0</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
        <span class="n">vm</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lamv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vm</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lamn</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vl</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">dl</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">pbdv_seq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parabolic cylinder functions Dv(x) and derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of the parabolic cylinder function</span>
<span class="sd">    x : float</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dv : ndarray</span>
<span class="sd">        Values of D_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>
<span class="sd">    dp : ndarray</span>
<span class="sd">        Derivatives D_vi&#39;(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 13.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span><span class="o">-</span><span class="n">n</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">v0</span>
    <span class="n">dv</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">pbdv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dv</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">pbvv_seq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parabolic cylinder functions Vv(x) and derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of the parabolic cylinder function</span>
<span class="sd">    x : float</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dv : ndarray</span>
<span class="sd">        Values of V_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>
<span class="sd">    dp : ndarray</span>
<span class="sd">        Derivatives V_vi&#39;(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 13.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span><span class="o">-</span><span class="n">n</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">v0</span>
    <span class="n">dv</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">pbvv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dv</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">pbdn_seq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parabolic cylinder functions Dn(z) and derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of the parabolic cylinder function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dv : ndarray</span>
<span class="sd">        Values of D_i(z), for i=0, ..., i=n.</span>
<span class="sd">    dp : ndarray</span>
<span class="sd">        Derivatives D_i&#39;(z), for i=0, ..., i=n.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 13.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be an integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">cpb</span><span class="p">,</span> <span class="n">cpd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cpbdn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cpb</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">cpd</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">ber_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ber(x).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bei_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function bei(x).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ker_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ker(x).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kei_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function kei(x).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">berp_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ber&#39;(x).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">beip_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function bei&#39;(x).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kerp_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ker&#39;(x).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">keip_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function kei&#39;(x).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kelvin_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of all Kelvin functions.</span>

<span class="sd">    Returned in a length-8 tuple of arrays of length nt.  The tuple contains</span>
<span class="sd">    the arrays of zeros of (ber, bei, ker, kei, ber&#39;, bei&#39;, ker&#39;, kei&#39;).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">pro_cv_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Characteristic values for prolate spheroidal wave functions.</span>

<span class="sd">    Compute a sequence of characteristic values for the prolate</span>
<span class="sd">    spheroidal wave functions for mode m and n&#39;=m..n and spheroidal</span>
<span class="sd">    parameter c.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Modes must be integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">199</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Difference between n and m is too large.&quot;</span><span class="p">)</span>
    <span class="n">maxL</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">segv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="n">maxL</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">obl_cv_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Characteristic values for oblate spheroidal wave functions.</span>

<span class="sd">    Compute a sequence of characteristic values for the oblate</span>
<span class="sd">    spheroidal wave functions for mode m and n&#39;=m..n and spheroidal</span>
<span class="sd">    parameter c.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           http://jin.ece.illinois.edu/specfunc.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Modes must be integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">199</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Difference between n and m is too large.&quot;</span><span class="p">)</span>
    <span class="n">maxL</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">segv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="n">maxL</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">ellipk</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Complete elliptic integral of the first kind.</span>

<span class="sd">    This function is defined as</span>

<span class="sd">    .. math:: K(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{-1/2} dt</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        The parameter of the elliptic integral.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    K : array_like</span>
<span class="sd">        Value of the elliptic integral.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For more precision around point m = 1, use `ellipkm1`, which this</span>
<span class="sd">    function calls.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ellipkm1 : Complete elliptic integral of the first kind around m = 1</span>
<span class="sd">    ellipkinc : Incomplete elliptic integral of the first kind</span>
<span class="sd">    ellipe : Complete elliptic integral of the second kind</span>
<span class="sd">    ellipeinc : Incomplete elliptic integral of the second kind</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ellipkm1</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">agm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Arithmetic, Geometric Mean.</span>

<span class="sd">    Start with a_0=a and b_0=b and iteratively compute</span>

<span class="sd">    a_{n+1} = (a_n+b_n)/2</span>
<span class="sd">    b_{n+1} = sqrt(a_n*b_n)</span>

<span class="sd">    until a_n=b_n.   The result is agm(a, b)</span>

<span class="sd">    agm(a, b)=agm(b, a)</span>
<span class="sd">    agm(a, a) = a</span>
<span class="sd">    min(a, b) &lt; agm(a, b) &lt; max(a, b)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span> <span class="o">/</span> <span class="n">ellipkm1</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The number of combinations of N things taken k at a time.</span>

<span class="sd">    This is often expressed as &quot;N choose k&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int, ndarray</span>
<span class="sd">        Number of things.</span>
<span class="sd">    k : int, ndarray</span>
<span class="sd">        Number of elements taken.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If `exact` is False, then floating point precision is used, otherwise</span>
<span class="sd">        exact long integer is computed.</span>
<span class="sd">    repetition : bool, optional</span>
<span class="sd">        If `repetition` is True, then the number of combinations with</span>
<span class="sd">        repetition is computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : int, ndarray</span>
<span class="sd">        The total number of combinations.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Array arguments accepted only for exact=False case.</span>
<span class="sd">    - If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import comb</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([3, 4])</span>
<span class="sd">    &gt;&gt;&gt; n = np.array([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; comb(n, k, exact=False)</span>
<span class="sd">    array([ 120.,  210.])</span>
<span class="sd">    &gt;&gt;&gt; comb(10, 3, exact=True)</span>
<span class="sd">    120L</span>
<span class="sd">    &gt;&gt;&gt; comb(10, 3, exact=True, repetition=True)</span>
<span class="sd">    220L</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">repetition</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">comb</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_comb_int</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">binom</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">cond</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Permutations of N things taken k at a time, i.e., k-permutations of N.</span>

<span class="sd">    It&#39;s also known as &quot;partial permutations&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int, ndarray</span>
<span class="sd">        Number of things.</span>
<span class="sd">    k : int, ndarray</span>
<span class="sd">        Number of elements taken.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If `exact` is False, then floating point precision is used, otherwise</span>
<span class="sd">        exact long integer is computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : int, ndarray</span>
<span class="sd">        The number of k-permutations of N.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Array arguments accepted only for exact=False case.</span>
<span class="sd">    - If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import perm</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([3, 4])</span>
<span class="sd">    &gt;&gt;&gt; n = np.array([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; perm(n, k)</span>
<span class="sd">    array([  720.,  5040.])</span>
<span class="sd">    &gt;&gt;&gt; perm(10, 3, exact=True)</span>
<span class="sd">    720</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">poch</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">cond</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="c1"># http://stackoverflow.com/a/16327037/125507</span>
<span class="k">def</span> <span class="nf">_range_prod</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Product of a range of numbers.</span>

<span class="sd">    Returns the product of</span>
<span class="sd">    lo * (lo+1) * (lo+2) * ... * (hi-2) * (hi-1) * hi</span>
<span class="sd">    = hi! / (lo-1)!</span>

<span class="sd">    Breaks into smaller products first for speed:</span>
<span class="sd">    _range_prod(2, 9) = ((2*3)*(4*5))*((6*7)*(8*9))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span> <span class="o">+</span> <span class="n">lo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">_range_prod</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">*</span> <span class="n">_range_prod</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lo</span>
    <span class="k">return</span> <span class="n">lo</span> <span class="o">*</span> <span class="n">hi</span>


<div class="viewcode-block" id="factorial"><a class="viewcode-back" href="../../../reference/pulse2percept.electrode2currentmap.html#pulse2percept.electrode2currentmap.factorial">[docs]</a><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The factorial of a number or array of numbers.</span>

<span class="sd">    The factorial of non-negative integer `n` is the product of all</span>
<span class="sd">    positive integers less than or equal to `n`::</span>

<span class="sd">        n! = n * (n - 1) * (n - 2) * ... * 1</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int or array_like of ints</span>
<span class="sd">        Input values.  If ``n &lt; 0``, the return value is 0.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If True, calculate the answer exactly using long integer arithmetic.</span>
<span class="sd">        If False, result is approximated in floating point rapidly using the</span>
<span class="sd">        `gamma` function.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nf : float or int or ndarray</span>
<span class="sd">        Factorial of `n`, as integer or float depending on `exact`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For arrays with ``exact=True``, the factorial is computed only once, for</span>
<span class="sd">    the largest input, with each other result computed in the process.</span>
<span class="sd">    The output dtype is increased to ``int64`` or ``object`` if necessary.</span>

<span class="sd">    With ``exact=False`` the factorial is approximated using the gamma</span>
<span class="sd">    function:</span>

<span class="sd">    .. math:: n! = \Gamma(n+1)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import factorial</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; factorial(arr, exact=False)</span>
<span class="sd">    array([   6.,   24.,  120.])</span>
<span class="sd">    &gt;&gt;&gt; factorial(arr, exact=True)</span>
<span class="sd">    array([  6,  24, 120])</span>
<span class="sd">    &gt;&gt;&gt; factorial(5, exact=True)</span>
<span class="sd">    120L</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">un</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

            <span class="c1"># Convert to object array of long ints if np.int can&#39;t handle size</span>
            <span class="k">if</span> <span class="n">un</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="nb">object</span>
            <span class="k">elif</span> <span class="n">un</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

            <span class="c1"># Handle invalid/trivial values</span>
            <span class="n">un</span> <span class="o">=</span> <span class="n">un</span><span class="p">[</span><span class="n">un</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Calculate products of each range of numbers</span>
            <span class="k">if</span> <span class="n">un</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">un</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">==</span> <span class="n">un</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">un</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">un</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">un</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">val</span> <span class="o">*=</span> <span class="n">_range_prod</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">==</span> <span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">factorial2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Double factorial.</span>

<span class="sd">    This is the factorial with every second value skipped.  E.g., ``7!! = 7 * 5</span>
<span class="sd">    * 3 * 1``.  It can be approximated numerically as::</span>

<span class="sd">      n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd</span>
<span class="sd">          = 2**(n/2) * (n/2)!                           n even</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int or array_like</span>
<span class="sd">        Calculate ``n!!``.  Arrays are only supported with `exact` set</span>
<span class="sd">        to False.  If ``n &lt; 0``, the return value is 0.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        The result can be approximated rapidly using the gamma-formula</span>
<span class="sd">        above (default).  If `exact` is set to True, calculate the</span>
<span class="sd">        answer exactly using integer arithmetic.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nff : float or int</span>
<span class="sd">        Double factorial of `n`, as an int or a float depending on</span>
<span class="sd">        `exact`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import factorial2</span>
<span class="sd">    &gt;&gt;&gt; factorial2(7, exact=False)</span>
<span class="sd">    array(105.00000000000001)</span>
<span class="sd">    &gt;&gt;&gt; factorial2(7, exact=True)</span>
<span class="sd">    105L</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">*=</span> <span class="n">k</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">oddn</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">cond1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">evenn</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">cond2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">nd2o</span> <span class="o">=</span> <span class="n">oddn</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">nd2e</span> <span class="o">=</span> <span class="n">evenn</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">place</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">cond1</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nd2o</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">nd2o</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="n">place</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nd2e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">nd2e</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">factorialk</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multifactorial of n of order k, n(!!...!).</span>

<span class="sd">    This is the multifactorial of n skipping k values.  For example,</span>

<span class="sd">      factorialk(17, 4) = 17!!!! = 17 * 13 * 9 * 5 * 1</span>

<span class="sd">    In particular, for any integer ``n``, we have</span>

<span class="sd">      factorialk(n, 1) = factorial(n)</span>

<span class="sd">      factorialk(n, 2) = factorial2(n)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Calculate multifactorial. If `n` &lt; 0, the return value is 0.</span>
<span class="sd">    k : int</span>
<span class="sd">        Order of multifactorial.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If exact is set to True, calculate the answer exactly using</span>
<span class="sd">        integer arithmetic.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : int</span>
<span class="sd">        Multifactorial of `n`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        Raises when exact is False</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import factorialk</span>
<span class="sd">    &gt;&gt;&gt; factorialk(5, 1, exact=True)</span>
<span class="sd">    120L</span>
<span class="sd">    &gt;&gt;&gt; factorialk(5, 3, exact=True)</span>
<span class="sd">    10L</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">*</span><span class="n">j</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="k">def</span> <span class="nf">zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Riemann zeta function.</span>

<span class="sd">    The two-argument version is the Hurwitz zeta function:</span>

<span class="sd">    .. math:: \zeta(x, q) = \sum_{k=0}^{\infty} \frac{1}{(k + q)^x},</span>

<span class="sd">    Riemann zeta function corresponds to ``q = 1``.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    zetac</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">_zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Michael Beyeler, Ariel Rokem, Geoff Boynton, and Ione Fine, The University of Washington.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>